<!-- Generated by Ruler -->


<!-- Source: .ruler/SYSTEM-INSTRUCTION.MODULE-DESIGN.md -->

# MODULE AND FILE DESIGN

---

## SYSTEM INSTRUCTION: MODULE AND FILE DESIGN

You are not allowed to introduce or extend “god modules” (multi-purpose megafiles). Every change must keep code split into small, single-responsibility modules inside clear feature slices.

#### 1. Core rule: one file, one reason to change

When you touch or create a file, it must have exactly one primary responsibility.

The following responsibilities must not coexist in the same file:

* HTTP/transport concerns (routes, request/response)
* Domain logic or business rules
* Integration logic (AI, DB, external APIs, SDKs)
* Complex UI layout or widget implementations
* Large configuration data (prompts, icon maps, class maps)

If a file does more than one of these, split it.

#### 2. Always work inside a feature slice

All code lives inside a feature-oriented directory (vertical slice), not in generic “utils” or giant shared modules.

Examples of slices (names are illustrative):

* `session-analysis`
* `session-coach-chat`
* `session-parser`
* `viewer`
* `timeline`
* `code-block`
* `ui-primitives`

Within each slice, use these internal layers:

* `core/` – types, invariants, and pure functions (no frameworks, no I/O)
* `usecases/` or `services/` – “do X” operations composed from core
* `infra/` or `adapters/` – AI, DB, HTTP clients, logging, SDK wiring
* `http/` – route handlers, validation, HTTP-level error mapping
* `ui/` or `components/` – React components and view models

Do not cross these layers inside a single file.

#### 3. Back-end rules

Route files:

* Only define routes, validate input, call a single usecase, and map errors to HTTP.
* No domain rules, no AI calls, no DB access inside route files.

Usecase/service files:

* A usecase file exports one main function representing a single operation.
* It only depends on `core` logic and abstractions for infra (interfaces), not concrete SDKs.
* No framework or transport imports (`express`, `next`, `remix`, etc.) in usecases.

Infra files:

* Wrap specific providers (AI, DB, external APIs).
* Contain low-level error translation and retry policies.
* Do not contain domain-level branching (e.g., “if summary vs if hook-discovery”) beyond what’s needed to talk to the provider.

Prompts and large config:

* Long AI prompts and configuration blobs must live in their own modules under the feature slice (e.g. `prompts/` or `config/`).
* Runtime logic imports these constants; it never embeds large prompt strings or maps inline.

#### 4. Front-end rules

Page/route components:

* Thin shells: read loader data, set up providers, and compose child components.
* No complex feature logic or massive event orchestration inside pages.

Hooks and state:

* Use dedicated hooks/stores per feature (e.g. `useXxxModel`, `xxx.store.ts`) for complex state and derived calculations.
* Hooks must not render JSX; they compute data and expose callbacks.

UI components:

* A component file is either:

  * A container component (wires hooks/state to child components), or
  * A presentational component (pure props → JSX)
* Do not mix container concerns (data fetching, global coordination) with large presentational trees in the same file if it becomes complex.

Large widgets:

* Complex widgets (date-time input, code block, modal, timeline, inspector) are treated as mini-libraries:

  * `core/` for pure logic and configuration
  * `ui/` for React components
  * `infra/` for DOM-level behavior (e.g., search highlighting, portals), if needed
* Big static maps (icon maps, key bindings) live in separate config files, not inline inside main components.

#### 5. What to do when you touch a large file

If you need to change a file that already violates these rules:

* Do not add new responsibilities to it.
* Extract the new logic into a new file in the appropriate slice/layer, then call it from the old file.
* When practical, opportunistically peel off existing responsibilities into new modules instead of expanding the megafile.

#### 6. Hard constraints

* No new file may exceed a single, clear responsibility.
* No new route file may call AI/DB/SDKs directly; it must call a usecase.
* No new React page or main panel component may contain more than one major feature’s logic; cross-feature coordination must go through shared hooks/stores, not giant all-in-one components.
* Prompts and large data/config are never embedded inline with logic.

This instruction is the first thing to check before writing or modifying any code. If a change would violate any of the rules above, restructure the code and create additional files instead of expanding an existing one.



<!-- Source: .ruler/tanstack-environment-server-client-only-rules.md -->

# ClientOnly

Client-only render to avoid SSR hydration issues. Import from `@tanstack/react-router`:

```typescript
import { ClientOnly } from '@tanstack/react-router';

<ClientOnly fallback={<span>—</span>}>
  <ComponentThatUsesClientHooks />
</ClientOnly>
```

Alternative: Custom implementation using mounted pattern if needed (see hydration errors below).

# Environment functions

From `@tanstack/react-start`:

## createIsomorphicFn

Adapts to client/server:

```typescript
import { createIsomorphicFn } from '@tanstack/react-start';
const getEnv = createIsomorphicFn()
  .server(() => 'server')
  .client(() => 'client');
getEnv(); // 'server' on server, 'client' on client
```

Partial: `.server()` no-op on client, `.client()` no-op on server.

## createServerOnlyFn / createClientOnlyFn

RC1: `serverOnly` → `createServerOnlyFn`, `clientOnly` → `createClientOnlyFn`

Strict environment execution (throws if called wrong env):

```typescript
import { createServerOnlyFn, createClientOnlyFn } from '@tanstack/react-start';
const serverFn = createServerOnlyFn(() => 'bar'); // throws on client
const clientFn = createClientOnlyFn(() => 'bar'); // throws on server
```

Tree-shaken: client code removed from server bundle, server code removed from client bundle.

# Hydration errors

Mismatch: Server HTML differs from client render. Common causes: Intl (locale/timezone), Date.now(), random IDs, responsive logic, feature flags, user prefs.

Strategies:
1. Make server and client match: deterministic locale/timezone on server (cookie or Accept-Language header), compute once and hydrate as initial state.
2. Let client tell environment: set cookie with client timezone on first visit, SSR uses UTC until then.
3. Make it client-only: wrap unstable UI in `<ClientOnly>` to avoid SSR mismatches.
4. Disable/limit SSR: use selective SSR (`ssr: 'data-only'` or `false`) when server HTML cannot be stable.
5. Last resort: React's `suppressHydrationWarning` for small known-different nodes (use sparingly).

Checklist: Deterministic inputs (locale, timezone, feature flags). Prefer cookies for client context. Use `<ClientOnly>` for dynamic UI. Use selective SSR when server HTML unstable. Avoid blind suppression.

# TanStack Start basics

Depends: @tanstack/react-router, Vite. Router: getRouter() (was createRouter() in beta). routeTree.gen.ts auto-generated on first dev run. Optional: server handler via @tanstack/react-start/server; client hydrate via StartClient from @tanstack/react-start/client. RC1: Import StartClient from @tanstack/react-start/client (not @tanstack/react-start). StartClient no longer requires router prop. Root route head: utf-8, viewport, title; component wraps Outlet in RootDocument. Routes: createFileRoute() code-split + lazy-load; loader runs server/client. Navigation: Link (typed), useNavigate (imperative), useRouter (instance).

# Server functions

createServerFn({ method }) + zod .inputValidator + .handler(ctx). After mutations: router.invalidate(); queryClient.invalidateQueries(['entity', id]).

# Typed Links

Link to="/posts/$postId" with params; activeProps for styling.



<!-- Source: .ruler/tanstack-query-rules.md -->

# TanStack Query Rules

Server state via TanStack Query + server functions. Type-safe fetching and mutations.

## Query Pattern

Define in `lib/{resource}/queries.ts` using `queryOptions`:

```typescript
export const todosQueryOptions = () =>
  queryOptions({
    queryKey: ['todos'],
    queryFn: async ({ signal }) => await getTodos({ signal }),
    staleTime: 1000 * 60 * 5,
    gcTime: 1000 * 60 * 10,
  });
```

Use: `const { data, isLoading } = useQuery(todosQueryOptions())`. Prefer `useSuspenseQuery` with Suspense.

## Server Functions in Queries

Call server functions directly in `queryFn`. No `useServerFn` hook. TanStack Start proxies. Pass `signal` for cancellation.

## Mutation Pattern

```typescript
const mutation = useMutation({
  mutationFn: async (text: string) => await createTodo({ data: { text } }),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: todosQueryOptions().queryKey });
    toast.success('Success');
  },
  onError: (error) => toast.error(error.message || 'Failed'),
});
```

Call via `mutation.mutate(data)` or `mutateAsync` for promises.

## Query Invalidation

After mutations: `queryClient.invalidateQueries({ queryKey: ... })`. Use specific keys, not broad.

## Mutation States

Access: `isPending`, `isError`, `isSuccess`, `error`, `data`. Disable UI during `isPending`.

## Error Handling

Handle in `onError`. Toast messages. Access: `error.message || 'Default'`.

## Query Keys

Hierarchical: `['todos']`, `['todo', id]`, `['todos', 'completed']`. Include all affecting variables.

## Stale Time vs GC Time

`staleTime`: freshness duration (no refetch). Default 0. Set for stable data.
`gcTime`: unused cache duration (was `cacheTime`). Default 5min. Memory management.

## Infinite Queries

`useInfiniteQuery` for pagination. Required: `initialPageParam`, `getNextPageParam`, `fetchNextPage`. Access `data.pages`. Check `hasNextPage` before fetching.

## Optimistic Updates

`onMutate` for optimistic updates. Rollback in `onError`. Update cache via `queryClient.setQueryData`.

## Best Practices

1. Queries in `lib/{resource}/queries.ts` with `queryOptions`
2. Call server functions directly (no `useServerFn` in callbacks)
3. Invalidate after mutations
4. Toast for feedback
5. Handle loading/error states
6. Use TypeScript types from query options
7. Set `staleTime`/`gcTime` appropriately
8. Prefer `useSuspenseQuery` with Suspense
