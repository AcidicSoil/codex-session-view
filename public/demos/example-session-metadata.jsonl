{"timestamp":"2025-11-23T19:24:17.722Z","type":"session_meta","payload":{"id":"019ab22c-95af-7160-b11d-8f552d0ce721","timestamp":"2025-11-23T19:24:17.712Z","cwd":"/home/user/projects/temp/codex-session-view","originator":"codex_cli_rs","cli_version":"0.63.0","instructions":"<!-- Generated by Ruler -->\n\n\n<!-- Source: .ruler/AGENTS.md -->\n\n# don't fetch or derive app state in useEffect\n\n# core rules\n\n1. Fetch on navigation in route loaders (SSR + streaming); optionally seed via `queryClient.ensureQueryData`. \\[1]\n2. Do server work on the server via TanStack Start server functions; after mutations call `router.invalidate()` and/or `queryClient.invalidateQueries()`. \\[2]\n3. Keep page/UI state in the URL with typed search params (`validateSearch`, `Route.useSearch`, `navigate`). \\[3]\n4. Reserve effects for real external effects only (DOM, subscriptions, analytics). Compute derived state during render; `useMemo` only if expensive. \\[4]\\[6]\n5. Hydration + Suspense: any update that suspends during hydration replaces SSR content with fallbacks. Wrap sync updates that might suspend in `startTransition` (direct import). Avoid rendering `isPending` during hydration. `useSyncExternalStore` always triggers fallbacks during hydration. \\[10]\n6. Data placement:\n\n   * Server-synced domain data → TanStack DB collections (often powered by TanStack Query via `queryCollectionOptions`, or a sync engine). Read with live queries. \\[11]\\[12]\\[14]\n   * Ephemeral UI/session (theme, modals, steppers, optimistic buffers) → zustand or local-only/localStorage collection. Do not mirror server data into zustand. \\[16]\\[14]\n   * Derived views → compute in render or via live queries. \\[12]\n\n# if your useEffect did X → use Y\n\n* Fetch on mount/param change → route loader (+ `ensureQueryData`). \\[1]\n* Submit/mutate → server function → then `router.invalidate()`/`qc.invalidateQueries()`. \\[2]\n* Sync UI ↔ querystring → typed search params + `navigate`. \\[3]\n* Derived state → compute during render (`useMemo` only if expensive). \\[4]\n* Subscribe external stores → `useSyncExternalStore` (expect hydration fallbacks). \\[5]\\[10]\n* DOM/listeners/widgets → small `useEffect`/`useLayoutEffect`. \\[6]\n* Synced list + optimistic UI → DB query collection + `onInsert`/`onUpdate`/`onDelete` or server fn + invalidate. \\[11]\\[13]\n* Realtime websocket/SSE patches → TanStack DB direct writes (`writeInsert/update/delete/upsert/batch`). \\[13]\n* Joins/aggregations → live queries. \\[12]\n* Local-only prefs/cross-tab → localStorage collection (no effects). \\[14]\n\n# idioms (names only)\n\n* Loader: `queryClient.ensureQueryData(queryOptions({ queryKey, queryFn }))` → read via `useSuspenseQuery` hydrated from loader. \\[1]\n* DB query collection: `createCollection(queryCollectionOptions({ queryKey, queryFn, queryClient, getKey }))` → read via live query. \\[11]\\[12]\n* Mutation (server-first): `createServerFn(...).handler(...)` → on success `qc.invalidateQueries`, `router.invalidate`; supports `<form action={serverFn.url}>`. \\[2]\n* DB persistence handlers: `onInsert`/`onUpdate`/`onDelete` → return `{ refetch?: boolean }`; pair with direct writes when skipping refetch. \\[13]\n* Search params as state: `validateSearch → Route.useSearch → navigate({ search })`. \\[3]\n* External store read: `useSyncExternalStore(subscribe, getSnapshot)`. \\[5]\n* Hydration-safe: `import { startTransition } from 'react'` for sync updates; avoid `useTransition`/`isPending` during hydration. \\[10]\n\n# decision checklist\n\n* Needed at render → loader (defer/stream). \\[1]\\[7]\n* User changed data → server fn → invalidate; or DB handlers/direct writes. \\[2]\\[13]\n* Belongs in URL → typed search params. \\[3]\n* Purely derived → render/live query. \\[4]\\[12]\n* External system only → effect. \\[6]\n* Hydration sensitive → `startTransition` for sync updates; expect fallbacks from external stores; avoid `isPending` during hydration. \\[10]\n* SSR/SEO → loader-based fetching with streaming/deferred; dehydrate/hydrate caches and DB snapshots. \\[7]\n\n# React 19 helpers\n\n* `useActionState` for form pending/error/result. \\[8]\n* `use` to suspend on promises. \\[9]\n\n# hydration + suspense playbook \\[10]\n\n* Rule: sync updates that suspend during hydration → fallback replaces SSR.\n* Quick fix: wrap updates with `startTransition` (direct import); re-wrap after `await`.\n* Avoid during hydration: using `useTransition` for the update, rendering `isPending`, `useDeferredValue` unless the suspensey child is memoized, any `useSyncExternalStore` mutation.\n* Safe during hydration: setting same value with `useState`/`useReducer`, `startTransition`-wrapped sync updates, `useDeferredValue` with `React.memo` around the suspensey child.\n* Compiler auto-memoization may help; treat as optimization.\n\n# TanStack DB: when/how \\[11]\\[12]\\[13]\\[14]\\[15]\\[16]\n\n* Use DB for server-synced domain data.\n* Load: `queryCollectionOptions` (simple fetch; optional refetch) or sync collections (Electric/Trailbase/RxDB).\n* Read: live queries (reactive, incremental; joins, `groupBy`, `distinct`, `order`, `limit`). \\[12]\n* Writes:\n\n  * Server-first → server fn → `router.invalidate()`/`qc.invalidateQueries()`. \\[2]\n  * Client-first → `onInsert`/`onUpdate`/`onDelete` (return `{ refetch: false }` if reconciling via direct writes/realtime). \\[13]\n  * Direct writes → `writeInsert/update/delete/upsert/batch` for websocket/SSE deltas, incremental pagination, server-computed fields; bypass optimistic layer and skip refetch. \\[13]\n* Behaviors: query collection treats `queryFn` result as full state; empty array deletes all; merge partial fetches before returning. \\[13]\n* Transaction merging reduces churn:\n\n  * insert+update → merged insert\n  * insert+delete → cancel\n  * update+delete → delete\n  * update+update → single union\n  * same type back-to-back → keep latest \\[15]\n* SSR: per-request store instances; never touch storage during SSR. \\[16]\\[14]\n\n# SSR/streaming/hydration with router + DB\n\n* In loaders: seed query via `ensureQueryData`; for DB, preload or dehydrate/hydrate snapshots so lists render instantly and stream updates. \\[1]\\[7]\\[12]\\[14]\n* After mutations: loader-owned → invalidate router/query; DB-owned → let collection refetch or apply direct writes. \\[2]\\[13]\n\n# micro-recipes\n\n* Avoid first-click spinner after SSR: wrap clicks with `startTransition`; don't render `isPending` until post-hydration. \\[10]\n* External store during hydration: defer interaction or isolate the suspense boundary; expect fallbacks. \\[5]\\[10]\n* Paginated load-more: fetch next page, then `collection.utils.writeBatch(() => writeInsert(...))` to append without refetching old pages. \\[13]\n* Realtime patches: `writeUpsert`/`writeDelete` from socket callback inside `writeBatch`. \\[13]\n\n# TanStack Start best practices\n\n## Selective SSR\n\n* Default `ssr: true` (change via `getRouter({ defaultSsr: false })`). SPA mode disables all server loaders/SSR.\n* Per-route `ssr`: `true` | `'data-only'` | `false`.\n* Functional `ssr(props)`: runs only on server initial request; can return `true` | `'data-only'` | `false` based on validated params/search.\n* Inheritance: child can only get less SSR (true → `'data-only'` or false; `'data-only'` → false).\n* Fallback: first route with `ssr: false` or `'data-only'` renders `pendingComponent` (or `defaultPendingComponent`) at least `minPendingMs` (or `defaultPendingMinMs`).\n* Root: you can disable SSR of root route component; `shellComponent` is always SSRed.\n\n## Zustand in TanStack Start\n\n* Use for client/UI/session and push-based domain state (theme, modals, wizards, optimistic UI, websocket buffers). Keep server data in loaders/Query.\n* Per-request store instance to avoid SSR leaks; inject via Router context; dehydrate/hydrate via `router.dehydrate`/`router.hydrate` so snapshots stream with the page.\n* After navigation resolution, clear transient UI with `router.subscribe('onResolved', ...)`.\n* Mutations: do work in server fn → optionally update store optimistically → `router.invalidate` to reconcile with loader data.\n* Persist middleware only for client/session; avoid touching storage during SSR.\n* Use atomic selectors (`useStore(s => slice)`) and equality helpers.\n\n## Project constraints\n\n* Use pnpm.\n* All route files are TypeScript React (`.tsx`).\n* Use alias imports: `~` resolves to root `./src`.\n* Never update `.env`; update `.env.example` instead.\n* Never start the dev server with `pnpm run dev` or `npm run dev`.\n* Never create a local pnpm --store\n* Important: Do not remove, hide, or rename any existing features or\n  UI options (even temporarily) unless I explicitly ask for it. If something isn't fully wired yet, keep the UX surface intact and stub/annotate it instead of deleting it.\n\n## docs map\n\n\\[1] router data loading · \\[2] server functions · \\[3] search params · \\[4] you might not need an effect · \\[5] `useSyncExternalStore` · \\[6] synchronizing with effects · \\[7] SSR/streaming · \\[8] `useActionState` · \\[9] `use` · \\[10] hydration + suspense guide · \\[11] TanStack DB query collection · \\[12] live queries · \\[13] direct writes + persistence handlers · \\[14] collections catalog · \\[15] transactions + optimistic actions · \\[16] zustand in TanStack Start\n","source":"cli","model_provider":"openai","git":{"commit_hash":"56f6d355829b4a905ce793ac6e55b82705d18bec","branch":"main","repository_url":"https://github.com/AcidicSoil/codex-session-view"}}}