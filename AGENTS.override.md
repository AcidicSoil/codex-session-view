<!-- Generated by Ruler -->

<!-- Source: .ruler/AGENTS.md -->

# don't fetch or derive app state in useEffect

# core rules

1. Fetch on navigation in route loaders (SSR + streaming); optionally seed via `queryClient.ensureQueryData`. \[1]
2. Do server work on the server via TanStack Start server functions; after mutations call `router.invalidate()` and/or `queryClient.invalidateQueries()`. \[2]
3. Keep page/UI state in the URL with typed search params (`validateSearch`, `Route.useSearch`, `navigate`). \[3]
4. Reserve effects for real external effects only (DOM, subscriptions, analytics). Compute derived state during render; `useMemo` only if expensive. \[4]\[6]
5. Hydration + Suspense: any update that suspends during hydration replaces SSR content with fallbacks. Wrap sync updates that might suspend in `startTransition` (direct import). Avoid rendering `isPending` during hydration. `useSyncExternalStore` always triggers fallbacks during hydration. \[10]
6. Data placement:

   * Server-synced domain data → TanStack DB collections (often powered by TanStack Query via `queryCollectionOptions`, or a sync engine). Read with live queries. \[11]\[12]\[14]
   * Ephemeral UI/session (theme, modals, steppers, optimistic buffers) → zustand or local-only/localStorage collection. Do not mirror server data into zustand. \[16]\[14]
   * Derived views → compute in render or via live queries. \[12]

# if your useEffect did X → use Y

* Fetch on mount/param change → route loader (+ `ensureQueryData`). \[1]
* Submit/mutate → server function → then `router.invalidate()`/`qc.invalidateQueries()`. \[2]
* Sync UI ↔ querystring → typed search params + `navigate`. \[3]
* Derived state → compute during render (`useMemo` only if expensive). \[4]
* Subscribe external stores → `useSyncExternalStore` (expect hydration fallbacks). \[5]\[10]
* DOM/listeners/widgets → small `useEffect`/`useLayoutEffect`. \[6]
* Synced list + optimistic UI → DB query collection + `onInsert`/`onUpdate`/`onDelete` or server fn + invalidate. \[11]\[13]
* Realtime websocket/SSE patches → TanStack DB direct writes (`writeInsert/update/delete/upsert/batch`). \[13]
* Joins/aggregations → live queries. \[12]
* Local-only prefs/cross-tab → localStorage collection (no effects). \[14]

# idioms (names only)

* Loader: `queryClient.ensureQueryData(queryOptions({ queryKey, queryFn }))` → read via `useSuspenseQuery` hydrated from loader. \[1]
* DB query collection: `createCollection(queryCollectionOptions({ queryKey, queryFn, queryClient, getKey }))` → read via live query. \[11]\[12]
* Mutation (server-first): `createServerFn(...).handler(...)` → on success `qc.invalidateQueries`, `router.invalidate`; supports `<form action={serverFn.url}>`. \[2]
* DB persistence handlers: `onInsert`/`onUpdate`/`onDelete` → return `{ refetch?: boolean }`; pair with direct writes when skipping refetch. \[13]
* Search params as state: `validateSearch → Route.useSearch → navigate({ search })`. \[3]
* External store read: `useSyncExternalStore(subscribe, getSnapshot)`. \[5]
* Hydration-safe: `import { startTransition } from 'react'` for sync updates; avoid `useTransition`/`isPending` during hydration. \[10]

# decision checklist

* Needed at render → loader (defer/stream). \[1]\[7]
* User changed data → server fn → invalidate; or DB handlers/direct writes. \[2]\[13]
* Belongs in URL → typed search params. \[3]
* Purely derived → render/live query. \[4]\[12]
* External system only → effect. \[6]
* Hydration sensitive → `startTransition` for sync updates; expect fallbacks from external stores; avoid `isPending` during hydration. \[10]
* SSR/SEO → loader-based fetching with streaming/deferred; dehydrate/hydrate caches and DB snapshots. \[7]

# React 19 helpers

* `useActionState` for form pending/error/result. \[8]
* `use` to suspend on promises. \[9]

# hydration + suspense playbook \[10]

* Rule: sync updates that suspend during hydration → fallback replaces SSR.
* Quick fix: wrap updates with `startTransition` (direct import); re-wrap after `await`.
* Avoid during hydration: using `useTransition` for the update, rendering `isPending`, `useDeferredValue` unless the suspensey child is memoized, any `useSyncExternalStore` mutation.
* Safe during hydration: setting same value with `useState`/`useReducer`, `startTransition`-wrapped sync updates, `useDeferredValue` with `React.memo` around the suspensey child.
* Compiler auto-memoization may help; treat as optimization.

# TanStack DB: when/how \[11]\[12]\[13]\[14]\[15]\[16]

* Use DB for server-synced domain data.
* Load: `queryCollectionOptions` (simple fetch; optional refetch) or sync collections (Electric/Trailbase/RxDB).
* Read: live queries (reactive, incremental; joins, `groupBy`, `distinct`, `order`, `limit`). \[12]
* Writes:

  * Server-first → server fn → `router.invalidate()`/`qc.invalidateQueries()`. \[2]
  * Client-first → `onInsert`/`onUpdate`/`onDelete` (return `{ refetch: false }` if reconciling via direct writes/realtime). \[13]
  * Direct writes → `writeInsert/update/delete/upsert/batch` for websocket/SSE deltas, incremental pagination, server-computed fields; bypass optimistic layer and skip refetch. \[13]
* Behaviors: query collection treats `queryFn` result as full state; empty array deletes all; merge partial fetches before returning. \[13]
* Transaction merging reduces churn:

  * insert+update → merged insert
  * insert+delete → cancel
  * update+delete → delete
  * update+update → single union
  * same type back-to-back → keep latest \[15]
* SSR: per-request store instances; never touch storage during SSR. \[16]\[14]

# SSR/streaming/hydration with router + DB

* In loaders: seed query via `ensureQueryData`; for DB, preload or dehydrate/hydrate snapshots so lists render instantly and stream updates. \[1]\[7]\[12]\[14]
* After mutations: loader-owned → invalidate router/query; DB-owned → let collection refetch or apply direct writes. \[2]\[13]

# micro-recipes

* Avoid first-click spinner after SSR: wrap clicks with `startTransition`; don't render `isPending` until post-hydration. \[10]
* External store during hydration: defer interaction or isolate the suspense boundary; expect fallbacks. \[5]\[10]
* Paginated load-more: fetch next page, then `collection.utils.writeBatch(() => writeInsert(...))` to append without refetching old pages. \[13]
* Realtime patches: `writeUpsert`/`writeDelete` from socket callback inside `writeBatch`. \[13]

# TanStack Start best practices

## Selective SSR

* Default `ssr: true` (change via `getRouter({ defaultSsr: false })`). SPA mode disables all server loaders/SSR.
* Per-route `ssr`: `true` | `'data-only'` | `false`.
* Functional `ssr(props)`: runs only on server initial request; can return `true` | `'data-only'` | `false` based on validated params/search.
* Inheritance: child can only get less SSR (true → `'data-only'` or false; `'data-only'` → false).
* Fallback: first route with `ssr: false` or `'data-only'` renders `pendingComponent` (or `defaultPendingComponent`) at least `minPendingMs` (or `defaultPendingMinMs`).
* Root: you can disable SSR of root route component; `shellComponent` is always SSRed.

## Zustand in TanStack Start

* Use for client/UI/session and push-based domain state (theme, modals, wizards, optimistic UI, websocket buffers). Keep server data in loaders/Query.
* Per-request store instance to avoid SSR leaks; inject via Router context; dehydrate/hydrate via `router.dehydrate`/`router.hydrate` so snapshots stream with the page.
* After navigation resolution, clear transient UI with `router.subscribe('onResolved', ...)`.
* Mutations: do work in server fn → optionally update store optimistically → `router.invalidate` to reconcile with loader data.
* Persist middleware only for client/session; avoid touching storage during SSR.
* Use atomic selectors (`useStore(s => slice)`) and equality helpers.

## Project constraints/Repository expectations

* Use pnpm.
* All route files are TypeScript React (`.tsx`).
* Use alias imports: `~` resolves to root `./src`.
* Never update `.env`; update `.env.example` instead.
* Never start the dev server with `pnpm run dev` or `npm run dev`.
* Never create a local pnpm --store
* Never use `git reset --hard HEAD`
* Before ending your turn:
  * Create e2e tests for webapp-testing by following instructions in `~/.codex/skills/webapp-testing/SKILL.md`
  * Run `pnpm lint`, resolve linting warnings and errors
  * Run `pnpm build`, resolve build errors if any
  * Documentation and test synchronization:
    * Revise/sync externally facing documentation.
    * Update CHANGELOG
    * Revise/sync old existing e2e tests until all e2e tests pass.

## docs map

\[1] router data loading · \[2] server functions · \[3] search params · \[4] you might not need an effect · \[5] `useSyncExternalStore` · \[6] synchronizing with effects · \[7] SSR/streaming · \[8] `useActionState` · \[9] `use` · \[10] hydration + suspense guide · \[11] TanStack DB query collection · \[12] live queries · \[13] direct writes + persistence handlers · \[14] collections catalog · \[15] transactions + optimistic actions · \[16] zustand in TanStack Start

<!-- Source: .ruler/file-size_and_responsibility-rule.md -->

### Repository-wide file-size and responsibility rule

Scope: all TypeScript/JavaScript files under `src` (routes, hooks, server functions, utilities, db, etc.), excluding config and test fixtures.

```md
# file size and responsibility rules

## core rules

1. One primary unit per file
   - Each file owns **one main thing**:
     - Components: one main component (existing rule).
     - Hooks: one main hook (`useXxx`).
     - Server functions: one main server function or handler group for a single route.
     - Utilities: one cohesive utility topic (e.g. `dateFormat`, `sessionSearch`, `featureFlags`).
     - Schema: one logical schema group (e.g. `session.schema.ts`).
   - Any additional exports must be:
     - Small helpers directly supporting the main unit, or
     - Type-only exports.

2. File-size limits (non-component, general case)
   - Soft target: **150–300 LOC** per file (excluding imports and types).
   - Warning zone: **> 400 LOC** → required refactor before adding new behavior.
   - Hard cap: **600 LOC**. No exceptions; split into smaller files before merging.

3. Split by concern
   - **Stateful logic, effects, orchestration → hooks/logic files**:
     - `FeatureName/FeatureName.hooks.ts`
     - `FeatureName/FeatureName.logic.ts`
   - **Pure data shaping, parsing, formatting → utility files**:
     - `FeatureName/FeatureName.utils.ts`
     - `FeatureName/FeatureName.format.ts`
   - **Types/interfaces/enums shared across files → type files**:
     - `FeatureName/FeatureName.types.ts`
   - **Route/server concerns → route/server files only**:
     - Keep HTTP handling, validation, and side effects here.
     - Push domain logic into shared `*.logic.ts` or `*.utils.ts`.

4. When to split a file (hard triggers, any file type)
   - File > **400 LOC** or diff adds > **80 LOC** to a file already > **300 LOC**.
   - File mixes **two or more** of:
     - Network/server I/O (fetch, db, server functions)
     - Business/domain logic (calculations, rules)
     - UI / presentation (components, JSX, templates)
     - Cross-cutting concerns (logging, metrics, feature flags)
   - File exports **many unrelated things**:
     - More than **5–7 public exports** with different purposes.
     - Utilities that clearly belong to different topics (e.g. date helpers + string helpers).
   - Control flow / branching is hard to scan:
     - Deeply nested conditionals or long switch statements (`> ~100 LOC`) that can be moved into dedicated helpers.

5. Structure conventions by file kind
   - **Hooks**:
     - `FeatureName/FeatureName.hooks.ts` → owns `useFeatureNameXxx` hooks.
     - No JSX, no DOM; only state, effects, and derived data.
   - **Logic / services**:
     - `FeatureName/FeatureName.logic.ts` or `FeatureName/service.ts`.
     - Pure, testable functions; no React imports.
   - **Utilities / formatting**:
     - `FeatureName/FeatureName.utils.ts`, `FeatureName/FeatureName.format.ts`.
     - Pure, side-effect-free; reusable across features.
   - **Types**:
     - `FeatureName/FeatureName.types.ts`.
     - No runtime code.
   - **Server functions / routes**:
     - One route or server function group per file.
     - Validation + wiring here; heavy domain logic pushed into `*.logic.ts`.

6. Review checklist (for any file)
   - [ ] Does this file have **one clearly named primary responsibility**?
   - [ ] Is the file within the **150–300 LOC target** and **< 400 LOC** unless it’s about to be split?
   - [ ] Are stateful logic and side effects separated from pure helpers?
   - [ ] Are different concerns (I/O, domain logic, formatting, UI) split into distinct files?
   - [ ] Are exported functions/types cohesive, or should some move to a `*.utils.ts` / `*.logic.ts` / `*.types.ts` file?


```

---

### Line-count thresholds as a rule of thumb

Use these as mental stop signs across the codebase:

* **Components (existing rule):**

  * Target: **150–250 LOC**
  * Refactor threshold: **> 400 LOC**
  * Hard cap: **600 LOC**

* **Hooks / logic modules:**

  * Target: **150–250 LOC**
  * Start considering a split: **> 300 LOC**
  * Must split before: **> 400 LOC**

* **Utility / formatting modules:**

  * Target: **150–300 LOC**
  * Start considering split: **> 350 LOC** or **> 8–10 exports**
  * Hard cap: **600 LOC**, but only if exports are tightly related.

* **Route / server function files:**

  * Target: **150–300 LOC** for the route file itself.
  * If adding behavior would push it **> 350–400 LOC**, push domain logic into a `*.logic.ts` or `*.service.ts` and keep the route thin.

Operational rule:

* Once any file crosses **~300 LOC** or starts handling **more than one major concern**, treat that as the point to factor logic into `*.hooks.ts`, `*.logic.ts`, `*.utils.ts`, and `*.types.ts` so the main file stays as a thin coordinator.

### General Rules

— Early development, no users. No backwards compatibility concerns. Do things RIGHT:
organized, zero tech debt. Never create compatibility shims.

* WE NEVER WANT WORKAROUNDS. we always want FULL implementations that are long term
sustainable for many >l000 users. so dont come up with half baked solutions
* Important: Do not remove, hide, or rename any existing features or UI options (even
temporarily) unless I explicitly ask for it. If something isn't fully wired yet, keep the UX surface intact and stub/annotate it instead of deleting it.

— Single source of truth: All business rules, validation, enums, flags, constants, and config live in the backend. UI is a pure view that reads them via API or shared types. Do not define duplicate rules or values in the frontend. When the UI needs new options or behavior, change the backend model/config first, then consume it from the UI. If you see frontend code copying backend data or logic, refactor to fetch it from the backend.

## Linting

ESLint + estint-plugin—solid + Prettier. Lint errors = real bugs.

## Types

— Never inline union types used in 2+ places — define once, import everywhere.

* Shared UI types (panel kinds, tab types, view modes) --> i.e., workbench/lib/*.ts' or co—located store.
— Domain types (API shapes, entities) --> `src/lib/types.ts` or near related code.
* Export both nullable (`Type | null`) and required (`Exclude<Type, null>`) variants when needed.

## Config-driven variants

No scattered if-chains with hardcoded strings. Define variants + behavior in one place:

```ts
export const KINDS = ['a', 'b', 'c'] as const
export type Kind = (typeof KINDS)[number]
export const KIND_CONFIG: Record<Kind, { /* behavior props */ }> = { a: {}, b: {}, c: {} }
// Usage: const cfg = KIND_CONFIG[kind]; cfg.doSomething && doSomething()
```

Add/rename variant = update config once; TS catches stale refs.

<!-- Source: .ruler/skill-usage.md -->

# Codex skills usage

* For every UI/frontend related task (new components, refactoring existing component, scanning through existing components, removing/replacing components, etc. ), first interpret the task under the applicable `AGENTS.md` rules, then apply `~/.codex/skills/frontend-design/SKILL.md`.
* For every logic/backend task (refactors, features, tests, docs, workflows, integrations, etc.), first interpret the task under the applicable [`AGENTS.override.md`, `src/AGENTS.md`] rules.
* Always reference `src/AGENTS.md` and follow section `MODULE AND FILE DESIGN` for all work/tasks performed under `src/`.
* Always report files that exceed the 400 line threshold at the end of each turn, use `pnpm thres` to locate these files. Any file reported and located under `src/` shall be considered in your end-turn report.
* Before ending turn, review work performed this run by referencing all sections under `file size and responsibility rules`. Report your findings if any work performed did not align with the rules.
